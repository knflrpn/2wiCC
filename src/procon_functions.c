#include "usb_descriptors.h"

static struct ControllerData controller_state;
uint8_t usb_special_buf[0x40]; // Buffer for special messages
uint8_t usb_norm_buf[0x40];	   // Buffer for normal messages
uint8_t polling_mode = 0;
uint8_t imu_enabled = 0;
bool special_report_pending = false;
bool special_report_queued = false;
static uint8_t tick = 0;
uint32_t last_report_time = 0;

void set_neutral_con()
{
	controller_state.analog[0] = 0xFF;
	controller_state.analog[1] = 0xF7;
	controller_state.analog[2] = 0x7F;
	controller_state.analog[3] = 0xFF;
	controller_state.analog[4] = 0xF7;
	controller_state.analog[5] = 0x7F;
	controller_state.charging_grip = 1;
}

static const uint8_t spi0x2000[144] = {
	0x00, 0x22, 0x84, 0x6E, 0xDC, 0x68, 0xEB, 0x69,
	0xD4, 0xC2, 0x5C, 0x61, 0x49, 0xE3, 0xDE, 0xAE,
	0x18, 0x52, 0x2A, 0x75, 0xD3, 0x53, 0x14, 0xF2,
	0xA7, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x95, 0x22,
	0x30, 0xB2, 0x8C, 0xC6, 0x81, 0x1A, 0x3A, 0x4B,
	0x1A, 0x1E, 0xBB, 0x5D, 0x1C, 0xC7, 0x41, 0xD9,
	0x5E, 0xC8, 0xBA, 0x21, 0x18, 0x9C, 0xAE, 0x3B,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x08, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

static const uint8_t spi0x6000[256] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6000 - 0x6007 // Serial number (none)
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6008 - 0x600F // Serial number (none)
	0xFF, 0xFF, 0x03, 0xA0, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6010 - 0x6017 // 6012=3 (procon)
	0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6018 - 0x601F // 601B=1 (color data later)
	0x39, 0x00, 0xB2, 0xFF, 0x5C, 0x01, 0x00, 0x40, // 0x6020 - 0x6027 // 6Axis cal data
	0x00, 0x40, 0x00, 0x40, 0x2C, 0x00, 0xCA, 0xFF, // 0x6028 - 0x602F // 6Axis cal data
	0x9F, 0xFF, 0x3B, 0x34, 0x3B, 0x34, 0x3B, 0x34, // 0x6030 - 0x6037 // 6Axis cal data
	//  x603D - x6045 	Left analog stick calibration
	//	x6046 - x604E 	Right analog stick calibration
	//	x6050 - x6052 	Body #RGB color, 24-bit
	//	x6053 - x6055 	Buttons #RGB color, 24-bit
	//	x6056 - x6058 	Left Grip #RGB color, 24-bit
	//	x6059 - x605B 	Right Grip #RGB color, 24-bit
	// NEW: center 800, max,min 600
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x60, // 0x6038 - 0x603F
	0x00, 0x08, 0x80, 0x00, 0x06, 0x60, 0x00, 0x08, // 0x6040 - 0x6047
	0x80, 0x00, 0x06, 0x60, 0x00, 0x06, 0x60, 0xFF, // 0x6048 - 0x604F
	0x32, 0x32, 0x32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6050 - 0x6057
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6058 - 0x605F
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6060 - 0x6067
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6068 - 0x606F
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6070 - 0x6077
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x6078 - 0x607F
	// x6080-x6085 	6-Axis Horizontal Offsets. (JC sideways)
	// x6086-x6097 	Stick device parameters 1
	// NEW: deadzone 6
	0x50, 0xFD, 0x00, 0x00, 0xC6, 0x0F, 0x0F, 0x30, // 0x6080 - 0x6087
	0x61, 0x06, 0x30, 0xF3, 0xD4, 0x14, 0x54, 0x41, // 0x6088 - 0x608F
	0x15, 0x54, 0xC7, 0x79, 0x9C, 0x33, 0x36, 0x63, // 0x6090 - 0x6097
	// x6098-x60A9 	Stick device parameters 2.
	0x0F, 0x30, 0x61, 0x06, 0x30, 0xF3, 0xD4, 0x14, // 0x6098 - 0x609F
	0x54, 0x41, 0x15, 0x54, 0xC7, 0x79, 0x9C, 0x33, // 0x60A0 - 0x60A7
	0x36, 0x63, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60A8 - 0x60AF
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60B0 - 0x60B7
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60B8 - 0x60BF
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60C0 - 0x60C7
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60C8 - 0x60CF
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60D0 - 0x60D7
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60D8 - 0x60DF
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60E0 - 0x60E7
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60E8 - 0x60EF
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0x60F0 - 0x60F7
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF	// 0x60F8 - 0x60FF
};

/* see https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering/blob/master/spi_flash_notes.md */

/* Gets a value from the controller's non-volatile memory */
void spi_read(uint16_t addr, uint8_t len, uint8_t *buffer)
{
	uint8_t *data = NULL;
	switch (addr & 0xF000)
	{
	case 0x6000:
		// Factory Configuration and Calibration
		data = (uint8_t *)&spi0x6000[addr & 0xFF];
		break;
	case 0x2000:
		// Pairing info
		data = (uint8_t *)&spi0x2000[addr & 0x7F];
		break;

	default:
		break;
	}

	if (data)
		memcpy(buffer, data, len);
	else
		memset(buffer, 0xFF, len);
}

void spi_write(uint16_t addr, uint8_t len, uint8_t const *buffer)
{
	// Not implemented
}

void spi_erase(uint16_t addr, uint8_t len)
{
	// Not implemented
}

/* Inserts the common controller data into the provided report */
static void fill_input_report(struct ControllerData *controller_data)
{
	memcpy(controller_data, &controller_state, sizeof(struct ControllerData));

	controller_data->timestamp = tick;
	controller_data->battery_level = battery_level_charging | battery_level_full;
	controller_data->connection_info = /* 0xe; */ 0x1;
	controller_data->vibrator_input_report = 0x70;

	tick += 3;
}

/* 0x30 is the full report with IMU data. */
static void input_report_0x30(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	// report ID
	usb_out_buf[0x00] = kReportIdInput30;

	fill_input_report((struct ControllerData *)&usb_out_buf[0x01]);
}

/* Used to ignore controller internal UART commands */
static void output_passthrough(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	const uint8_t response_h[] = {0x81, usb_in[1], 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	memcpy(usb_out_buf, response_h, sizeof(response_h));
}

/* Response to 80 01. Sends connection status and MAC data */
static void output_mac_addr(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	const uint8_t response_h[] = {
		0x81,
		0x01,
		0x00,
		0x03,
		0xc1,
		0xc9,
		0x3e,
		0xe9,
		0xb6,
		0x98,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
	memcpy(usb_out_buf, response_h, sizeof(response_h));
}

/* Used to ignore controller internal UART handshaking */
static void output_handshake(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	memset(usb_out_buf, 0, 0x40);
	usb_out_buf[0] = 0x81;
	usb_out_buf[1] = kSubTypeHandshake;
}

/* Used to ignore baud rate change */
static void output_baudrate(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	memset(usb_out_buf, 0, 0x40);
	usb_out_buf[0] = 0x81;
	usb_out_buf[1] = 0x03;
}

/* Used to ignore request to switch to bluetooth */
static void output_enable_usb_timeout(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	memset(usb_out_buf, 0, 0x40);
	usb_out_buf[0] = 0x81;
	usb_out_buf[1] = kSubTypeDisableUsbTimeout;
}

/* Used to ignore request to remain on USB (going to anyway) */
static void output_disable_usb_timeout(uint8_t const *usb_in, uint8_t *usb_out_buf)
{
	memset(usb_out_buf, 0, 0x40);
	usb_out_buf[0] = 0x81;
	usb_out_buf[1] = kSubTypeEnableUsbTimeout;
}

/* Check which action has been sent to the 0x80 endpoint */
static void output_report_0x80(uint8_t const *buf, uint8_t *usb_out_buf)
{
	switch (buf[1])
	{
	case 0x01: // mac addr
		output_mac_addr(buf, usb_out_buf);
		break;
		// handshake//baudrate
	case 0x02:
		output_handshake(buf, usb_out_buf);
		break;
	case 0x03:
		output_baudrate(buf, usb_out_buf);
		break;
	// usb timeout
	case 0x04:
		output_disable_usb_timeout(buf, usb_out_buf);
		break;
	case 0x05:
		output_enable_usb_timeout(buf, usb_out_buf);
		break;
	case 0x91:
	case 0x92:
		output_passthrough(buf, usb_out_buf);
		break;
	default:
		output_passthrough(buf, usb_out_buf);
		break;
	}
}

/* An unknown subcommand was sent to the 0x01 endpoint. */
static void output_report_0x01_unknown_subcmd(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct Report81Response *resp = (struct Report81Response *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);
	resp->subcommand_ack = 0x80;
	resp->subcommand = buf[10];
}

/* 0x01 subcommand 0x08: Set shipment low power state.
   This does nothing to this device, so just send a dummy response. */
static void output_report_0x01_0x08_lowpower_state(uint8_t const *buf, uint8_t *usb_out_buf)
{
	unsigned char rawData[64] = {
		0x21,
		0x06,
		0x8E,
		0x84,
		0x00,
		0x12,
		0x01,
		0x18,
		0x80,
		0x01,
		0x18,
		0x80,
		0x80,
		0x80,
		0x08,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
	static int iii = 0;
	rawData[0x01] = iii++;
	memcpy(usb_out_buf, rawData, sizeof(rawData));
}

/* 0x01 subcommand 0x02: Request device info. */
static void output_report_0x01_get_device_info(uint8_t const *buf, uint8_t *usb_out_buf)
{
	// Of note: procon, use colors in spi flash
	unsigned char rawData[64] = {
		0x21,
		0xf8,
		0x81,
		0x00,
		0x80,
		0x00,
		0x8f,
		0xf8,
		0x7a,
		0x53,
		0x78,
		0x78,
		0x00,
		0x82,
		0x02, // response to 02 subcommand
		0x04, // firmware version
		0x48, // firmware version
		0x03, // Procon
		0x02, // 02
		0x64, // MAC
		0xb6, // MAC
		0xc9, // MAC
		0x3e, // MAC
		0x91, // MAC
		0xe1, // MAC
		0x01, // 01
		0x01, // Colors in SPI
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};

	memcpy(usb_out_buf, rawData, 0x40);
	fill_input_report((struct ControllerData *)&usb_out_buf[0x01]);
}

/* 0x01 subcommand 0x03: Set input report mode.  This is expected to set mode to
   standard full mode (0x30). */
static void output_report_0x01_set_report_mode(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct Report81Response *resp = (struct Report81Response *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	// acknowledge
	resp->subcommand_ack = 0x80;
	resp->subcommand = 0x03;

	fill_input_report(&resp->controller_data);

	polling_mode = buf[11];
}

/* 0x01 subcommand 0x04: Trigger buttons elapsed time.  Not sure what this should do,
   so just send a canned response. */
static void output_report_0x01_trigger_elapsed(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct Report81Response *resp = (struct Report81Response *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;

	// acknowledge
	resp->subcommand_ack = 0x83;
	resp->subcommand = 0x04;

	fill_input_report(&resp->controller_data);

	const uint8_t resp_[] = {
		0x21, 0x0A, 0x8E, 0x84, 0x00, 0x12, 0x01, 0x18, 0x80, 0x01, 0x18, 0x80, 0x80,
		0x83, 0x04, 0x00, 0xCC, 0x00, 0xEE, 0x00, 0xFF, 0x00, 0x00, 0x00};

	memcpy(usb_out_buf, resp_, sizeof(resp_));
}

/* 0x01 subcommand 0x10: Read from SPI flash. */
static void output_report_0x01_readspi(uint8_t const *buf, uint8_t *usb_out_buf)
{

	struct SpiReadReport *resp = (struct SpiReadReport *)&usb_out_buf[0x01];
	uint16_t addr = buf[kSubCommandDataOffset] | (uint16_t)buf[kSubCommandDataOffset + 1] << 8;
	uint8_t len = buf[kSubCommandDataOffset + 4];

	memset(usb_out_buf, 0x00, 0x40);
	usb_out_buf[0x00] = kReportIdInput21;

	fill_input_report(&resp->controller_data);

	resp->subcommand_ack = 0x90;
	resp->subcommand = 0x10;
	resp->addr = addr;

	spi_read(addr, len, resp->spi_data);
}

/* 0x01 subcommand 0x11: Write to SPI flash. This will do nothing. */
static void output_report_0x01_writespi(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	uint16_t addr = *(uint16_t *)(&buf[kSubCommandDataOffset]);
	uint8_t len = buf[kSubCommandDataOffset + 4];

	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);

	spi_write(addr, len, &buf[kSubCommandDataOffset + 5]);
}

/* 0x01 subcommand 0x12: Erase SPI flash. This will do nothing. */
static void output_report_0x01_erasespi(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	uint16_t addr = *(uint16_t *)(&buf[kSubCommandDataOffset]);
	uint8_t len = buf[kSubCommandDataOffset + 4];

	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);
	spi_erase(addr, len);
}

/* 0x01 subcommand 0x30: Set controller lights. Might use for something later.*/
static void output_report_0x01_set_lights(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);
}

/* 0x01 subcommand 0x38: Set home button light. Might use for something later.*/
static void output_report_0x01_set_homelight(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);
}

/* 0x01 subcommand 0x40: Turn on or off IMU.*/
static void output_report_0x01_enable_imu(uint8_t const *buf, uint8_t *usb_out_buf)
{
	imu_enabled = buf[11];

	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);
}

/* 0x01 subcommand 0x41: Set IMU sensitivity.*/
static void output_report_0x01_set_imu_sensitivity(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;
	fill_input_report(&resp->controller_data);
}

/* 0x01 subcommand 0x48: Enable vibration. This will do nothing.*/
static void output_report_0x01_set_vibration(uint8_t const *buf, uint8_t *usb_out_buf)
{
	struct ResponseX81 *resp = (struct ResponseX81 *)&usb_out_buf[0x01];
	// report ID
	usb_out_buf[0x00] = kReportIdInput21;

	resp->subcommand_ack = 0x80;
	resp->subcommand = 0x48;

	fill_input_report(&resp->controller_data);
}

/* 0x01 subcommand 0x01: Manual BT pairing. This will do nothing.*/
static void output_report_0x01_bt_pairing(uint8_t const *buf, uint8_t *usb_out_buf)
{
	const uint8_t data_01[] = {
		0x21, 0xf6, 0x81, 0x00, 0x80, 0x00, 0x8f, 0xf8, 0x7a, 0x54, 0x58, 0x78, 0x00, 0x81, 0x01, 0x01, /* !.......zTXx.... */
		0xc1, 0xc9, 0x3e, 0xe9, 0xb6, 0x98, 0x00, 0x25, 0x08, 0x50, 0x72, 0x6f, 0x20, 0x43, 0x6f, 0x6e, /* ..>....%.Pro Con */
		0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, /* troller......h.. */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ................ */
	};

	const uint8_t data_02[] = {
		0x21,
		0xfd,
		0x81,
		0x00,
		0x80,
		0x00,
		0x90,
		0xe8,
		0x7a,
		0x53,
		0x58,
		0x78,
		0x00,
		0x81,
		0x01,
		0x02, /* !.......zSXx.... */
		0xe5,
		0xc8,
		0xe4,
		0x92,
		0x05,
		0xff,
		0xc9,
		0x8a,
		0x7d,
		0xea,
		0x15,
		0xf6,
		0x19,
		0xba,
		0x82,
		0x13, /* ........}....... */
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, /* ................ */
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};

	const uint8_t data_03[] = {
		0x21,
		0x05,
		0x81,
		0x00,
		0x80,
		0x00,
		0x90,
		0xc8,
		0x7a,
		0x53,
		0x58,
		0x78,
		0x00,
		0x81,
		0x01,
		0x03,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};

	uint8_t pairing_type = buf[11] /* data->pairing.type */;

	uint8_t *data = (uint8_t *)data_01;
	switch (pairing_type)
	{
	case 1:
		data = (uint8_t *)data_01;
		break;
	case 2:
		data = (uint8_t *)data_02;
		break;
	default:
	case 3:
		data = (uint8_t *)data_03;
		break;
	}
	memcpy(usb_out_buf, data, 0x40);
	fill_input_report((struct ControllerData *)&usb_out_buf[0x01]);
}

/* Endpoint 0x10 does nothing here. */
static void output_report_0x10(uint8_t const *buf, uint8_t *usb_out_buf)
{
	/** nothing **/
}

/* Reroute the various subcommands of the 0x01 endpoint. */
static void output_report_0x01(uint8_t const *buf, uint8_t *usb_out_buf)
{
	uint8_t subCmd = buf[10];

	switch (subCmd)
	{
	case 0x01:
		output_report_0x01_bt_pairing(buf, usb_out_buf);
		break;
	case 0x02: // get device info
		output_report_0x01_get_device_info(buf, usb_out_buf);
		break;
	case 0x03: // Set input report mode
		output_report_0x01_set_report_mode(buf, usb_out_buf);
		break;
	case 0x04:
		output_report_0x01_trigger_elapsed(buf, usb_out_buf);
		break;
	case 0x08: // Set low power state (nothing here)
		output_report_0x01_0x08_lowpower_state(buf, usb_out_buf);
		break;
	case 0x10: // Read SPI flash
		output_report_0x01_readspi(buf, usb_out_buf);
		break;
	case 0x11: // Write SPI flash
		output_report_0x01_writespi(buf, usb_out_buf);
		break;
	case 0x12: // Erase SPI flash
		output_report_0x01_erasespi(buf, usb_out_buf);
		break;
	case 0x30: // Set Lights
		output_report_0x01_set_lights(buf, usb_out_buf);
		break;
	case 0x38: // Set Home Light
		output_report_0x01_set_homelight(buf, usb_out_buf);
		break;
	case 0x40: // Enable Imu
		output_report_0x01_enable_imu(buf, usb_out_buf);
		break;
	case 0x41: // Set Imu Sensitivity
		output_report_0x01_set_imu_sensitivity(buf, usb_out_buf);
		break;
	case 0x48: // Enable Vibration
		output_report_0x01_set_vibration(buf, usb_out_buf);
		break;
	case 0x00:
	case 0x33:
	default:
		output_report_0x01_unknown_subcmd(buf, usb_out_buf);
		break;
	}
}
